enum TypeCell 
{
  EMPTY, WALL, DOT, SUPER_DOT, PAC // others ?
}

class Board 
{
  TypeCell _cells[][];
  PVector _position;
  int _nbCellsX;
  int _nbCellsY;
  int _cellSize; // cells should be square
  int _pacX;
  int _pacY;
  float _departX,_departY;
  
  
  Board(PVector position, int cellSize) {
    
    _position=position;
    _cellSize=cellSize;
    
   int[][] carte = {
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
    {1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1},
    {1,3,1,1,1,2,1,1,1,1,2,1,2,1,1,1,1,2,1,1,1,3,1},
    {1,2,1,1,1,2,1,1,1,1,2,1,2,1,1,1,1,2,1,1,1,2,1},
    {1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1},
    {1,2,1,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,1,2,1,2},
    {1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1},
    {1,1,1,1,1,2,1,1,1,1,2,1,2,1,1,1,1,2,1,1,1,1,1},
    {0,0,0,0,1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,1,2,0,0},
    {1,1,1,1,1,2,1,2,1,1,1,0,1,1,1,2,1,2,1,1,1,1,1},
    {2,2,2,2,2,2,2,1,2,0,0,0,0,0,1,2,2,2,2,2,2,2,2},
    {1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1,2,1,1,1,1,1},
    {0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,0},
    {1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,1,2,1,1},
    {1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,1},
    {1,2,1,1,1,2,1,1,1,1,2,1,2,1,1,1,1,2,1,1,1,2,1},
    {1,3,2,2,1,2,2,2,2,2,2,2,4,2,2,2,2,2,1,2,2,3,1},
    {1,1,1,2,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,1,2,1,1},
    {1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1},
    {1,2,1,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1,1,1},
    {1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1},
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};
    
    
   String[] map;
   map = loadStrings("levels/level1.txt");
  // String titre = map[0];
   
  

_nbCellsX= map.length;
_nbCellsY= map[1].length();
println(_nbCellsY, _nbCellsX);
_cells= new TypeCell[_nbCellsX][_nbCellsY];
for (int j=0; j<_nbCellsX; j++){
  String cur_line = map[j];
  for(int i=0; i<_nbCellsY; i++){
    char c = cur_line.charAt(i);
    if(c=='V'){
      _cells[j][i]= TypeCell.EMPTY;
    }
     else if(c=='x'){
      _cells[j][i]= TypeCell.WALL;
    }
     else if(c=='o'){
      _cells[j][i]= TypeCell.DOT;
    }
     else if(c=='O'){
      _cells[j][i]= TypeCell.SUPER_DOT;
     }
     else if(c=='P'){
      _cells[j][i]= TypeCell.PAC;
      
       _pacY=j;
       _pacX=i;
      _departX=_position.x+ (i*_cellSize);
      _departY=_position.y+ (j*_cellSize);
      
    }
    else{
       _cells[j][i]= TypeCell.EMPTY;
    }
    //print(c);
    //println();
    println(i, j);
  }
  println();
}
    
    

}
  
  PVector getCellCenter(int i, int j) {
    return null;
  }
  TypeCell getTypeCell(int x,int y){
    return _cells[y][x];
  } 
  
  void drawIt() {
    TypeCell c;
    float px,py;
    
  for (int x=0;x<_nbCellsY;x++){
   for(int y=0;y<_nbCellsX;y++){
    c =_cells[y][x];
   
     px=_position.x +x *_cellSize;
     py=_position.y +y *_cellSize;
     fill(0);
     noStroke();
     rect(px,py,_cellSize,_cellSize);
    if(c== TypeCell.EMPTY){
    //println(_cells[x][y]);
     fill(0);
      noStroke();
      rect(px,py,_cellSize,_cellSize);
    }
     else if(c==TypeCell.WALL){
      //println(_cells[x][y]);
      fill(0,0,255);
      strokeWeight(5);
      stroke(0);
      rect(px,py,_cellSize,_cellSize);
    }
     else if(c==TypeCell.DOT){
      
      fill(255,0,100);
      ellipseMode(CENTER);
      ellipse(px +_cellSize/2,py+_cellSize/2,_cellSize/4,_cellSize/4);
    }
     else if(c==TypeCell.SUPER_DOT){
      fill(255,0,100);
      ellipseMode(CENTER);
      ellipse(px +_cellSize/2,py+_cellSize/2,_cellSize/2,_cellSize/2);
    }
    if(c== TypeCell.PAC){
     
    }
    else{

    }
  }
}
    
  }
}
